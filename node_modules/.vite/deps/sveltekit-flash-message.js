import {
  BROWSER
} from "./chunk-IP2U24VQ.js";
import {
  writable
} from "./chunk-4ACJE5FR.js";
import "./chunk-X7HCJ7ZS.js";
import {
  get_store_value,
  onDestroy,
  tick
} from "./chunk-37SFPISJ.js";
import "./chunk-XSLCAIPP.js";
import {
  __publicField
} from "./chunk-XNHBATJA.js";

// node_modules/sveltekit-flash-message/dist/cookie-es-main/index.js
var encode = encodeURIComponent;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function serialize(name, value, options) {
  let opt = options || {};
  let enc = opt.encode || encode;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name)) {
    throw new TypeError("argument name is invalid");
  }
  let encodedValue = enc(value);
  if (encodedValue && !fieldContentRegExp.test(encodedValue)) {
    throw new TypeError("argument val is invalid");
  }
  let str = name + "=" + encodedValue;
  if (null != opt.maxAge) {
    let maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + opt.expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.sameSite) {
    let sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
}

// node_modules/sveltekit-flash-message/dist/client.js
import { navigating } from "$app/stores";

// node_modules/sveltekit-flash-message/dist/flashMessage.js
import { browser } from "$app/environment";

// node_modules/sveltekit-flash-message/dist/options.js
var defaultOptions = {
  clearArray: false,
  clearOnNavigate: true,
  clearAfterMs: 0,
  flashCookieOptions: {
    path: "/",
    maxAge: 120,
    httpOnly: false,
    sameSite: "strict"
  }
};
function mergeOptions(parentOptions, options) {
  return {
    ...parentOptions,
    ...options,
    flashCookieOptions: {
      ...parentOptions.flashCookieOptions,
      ...options == null ? void 0 : options.flashCookieOptions
    }
  };
}

// node_modules/sveltekit-flash-message/dist/flashMessage.js
var FlashMessage = class {
  constructor(message, options) {
    __publicField(this, "options");
    __publicField(this, "_message");
    __publicField(this, "_flashTimeout", 0);
    this.options = options ?? defaultOptions;
    this._message = {
      subscribe: message.subscribe,
      set: (value, options2) => message.update(($message) => this.update($message, value, (options2 == null ? void 0 : options2.concatenateArray) ?? false)),
      update: (updater, options2) => message.update(($message) => this.update($message, updater($message), (options2 == null ? void 0 : options2.concatenateArray) ?? false))
    };
  }
  get message() {
    return this._message;
  }
  get flashTimeout() {
    return this._flashTimeout;
  }
  update(current, newData, concatenateArray = false) {
    if (this._flashTimeout)
      clearTimeout(this.flashTimeout);
    if (concatenateArray && Array.isArray(newData)) {
      if (Array.isArray(current)) {
        if (current.length > 0 && newData.length > 0 && current[current.length - 1] === newData[newData.length - 1]) {
          return current;
        } else {
          return current.concat(newData);
        }
      }
    }
    if (browser && newData !== void 0 && this.options.clearAfterMs) {
      this._flashTimeout = setTimeout(() => {
        this.message.set(void 0);
      }, this.options.clearAfterMs);
    }
    return newData;
  }
};

// node_modules/sveltekit-flash-message/dist/router.js
var FlashRouter = class {
  constructor() {
    __publicField(this, "routes", /* @__PURE__ */ new Map());
    __publicField(this, "messageStore");
    this.messageStore = writable();
    this.routes.set("", new FlashMessage(this.messageStore));
    onDestroy(() => {
      for (const route of this.routes.values()) {
        clearTimeout(route.flashTimeout);
      }
    });
  }
  get defaultRoute() {
    return this.routes.get("");
  }
  has(routeId) {
    return this.routes.has(routeId);
  }
  getFlashMessage(routeId) {
    if (!routeId)
      return this.defaultRoute;
    if (this.routes.has(routeId))
      return this.routes.get(routeId);
    return this.getClosestRoute(routeId);
  }
  getClosestRoute(routeId) {
    const matchingRoutes = Array.from(this.routes.keys()).filter((key) => routeId.includes(key));
    if (!matchingRoutes.length) {
      return this.defaultRoute;
    }
    const longestRoute = matchingRoutes.reduce((prev, curr) => curr.length > prev.length ? curr : prev);
    return this.routes.get(longestRoute);
  }
  createRoute(routeId, data, options) {
    const closest = this.getClosestRoute(routeId);
    const newRoute = new FlashMessage(this.messageStore, mergeOptions(closest.options, options));
    newRoute.message.set(data);
    this.routes.set(routeId, newRoute);
    return newRoute;
  }
};

// node_modules/sveltekit-flash-message/dist/client.js
import { afterNavigate, beforeNavigate } from "$app/navigation";
var cookieName = "flash";
var routers = /* @__PURE__ */ new WeakMap();
function getRouter(page, initialData) {
  let router = routers.get(page);
  if (!router) {
    router = new FlashRouter();
    routers.set(page, router);
    router.getFlashMessage(get_store_value(page).route.id).message.set(initialData);
    subscribeToNavigation(page);
  }
  return router;
}
function subscribeToNavigation(page) {
  if (!BROWSER)
    return;
  page.subscribe(($page) => {
    const cookieData = parseFlashCookie();
    if (cookieData !== void 0) {
      const flash = getRouter(page).getFlashMessage($page.route.id);
      flash.message.set(cookieData, { concatenateArray: !flash.options.clearArray });
      clearFlashCookie(flash.options.flashCookieOptions);
    }
  });
  beforeNavigate((nav) => {
    var _a, _b;
    const navTo = (_a = nav == null ? void 0 : nav.to) == null ? void 0 : _a.route.id;
    if (navTo) {
      const flash = getRouter(page).getFlashMessage(navTo);
      if (flash.options.clearOnNavigate && ((_b = nav.from) == null ? void 0 : _b.route.id) != navTo) {
        flash.message.set(void 0);
      }
    }
  });
  afterNavigate(() => {
    const cookieData = parseFlashCookie();
    if (cookieData !== void 0) {
      const flash = getRouter(page).getFlashMessage(get_store_value(page).route.id);
      flash.message.set(cookieData, { concatenateArray: !flash.options.clearArray });
      clearFlashCookie(flash.options.flashCookieOptions);
    }
  });
}
function initFlash(page, options) {
  return _initFlash(page, options).message;
}
function _initFlash(page, options) {
  if (!BROWSER) {
    return new FlashMessage(writable(get_store_value(page).data.flash));
  }
  const _page = get_store_value(page);
  const Router = getRouter(page, _page.data.flash);
  function Router_getFlashMessage() {
    const route = Router.routes.get(Page_route());
    if (route)
      return route;
    return options ? Router_createRoute() : Router.getClosestRoute(Page_route());
  }
  function Router_createRoute() {
    return Router.createRoute(Page_route(), Page_initialData(), options);
  }
  const Page = {
    store: page,
    route: _page.route.id,
    initialdata: _page.data.flash,
    navigating
  };
  function Page_initialData() {
    return Page.initialdata;
  }
  function Page_route() {
    return Page.route ?? "";
  }
  return Router_getFlashMessage();
}
function getFlash(page, options) {
  return _initFlash(page, options).message;
}
async function updateFlash(page, update) {
  if (update)
    await update();
  const cookieData = parseFlashCookie();
  if (cookieData !== void 0) {
    if (BROWSER)
      await tick();
    const flash = getRouter(page).getFlashMessage(get_store_value(page).route.id);
    flash.message.set(cookieData, { concatenateArray: !flash.options.clearArray });
    clearFlashCookie(flash.options.flashCookieOptions);
  }
  return !!cookieData;
}
function clearFlashCookie(options) {
  if (BROWSER) {
    document.cookie = serialize(cookieName, "", {
      ...options,
      maxAge: 0
    });
  }
}
function parseFlashCookie() {
  const cookieString = document.cookie;
  if (!cookieString || !cookieString.includes(cookieName + "="))
    return void 0;
  function parseCookieString(str) {
    const output = {};
    if (!str)
      return output;
    return str.split(";").map((v) => v.split("=")).reduce((acc, v) => {
      acc[decodeURIComponent(v[0].trim())] = decodeURIComponent(v[1].trim());
      return acc;
    }, output);
  }
  const cookies = parseCookieString(cookieString);
  if (cookies[cookieName]) {
    try {
      return JSON.parse(cookies[cookieName]);
    } catch (e) {
    }
  }
  return void 0;
}
export {
  getFlash,
  initFlash,
  updateFlash
};
//# sourceMappingURL=sveltekit-flash-message.js.map
